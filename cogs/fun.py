from codecs import encode
from functools import partial
import io
import json
import random
from PIL import Image, ImageDraw, ImageFont, ImageOps
import unicodedata
import aiohttp
from discord.ext import commands
import discord

from cryptography.fernet import Fernet, InvalidToken
import pykakasi
from discord import app_commands
from consts import settings
from models import command_disable
import asyncio
import uuid
from deep_translator import GoogleTranslator
import aiofiles.os

import urllib.parse

from models import quest


class EditImageView(discord.ui.View):
    def __init__(self, user: discord.User):
        super().__init__(timeout=180)
        self.user = user

    @discord.ui.button(label="„Éç„Ç¨„Éù„Ç∏ÂèçËª¢", style=discord.ButtonStyle.blurple)
    async def negapoji(
        self, interaction: discord.Interaction, button: discord.ui.Button
    ):
        if interaction.user.id != self.user.id:
            return

        await interaction.response.defer(ephemeral=True)
        file = io.BytesIO(await interaction.message.attachments[0].read())
        image = await asyncio.to_thread(Image.open, file)
        image = await asyncio.to_thread(image.convert, "RGB")
        imv = await asyncio.to_thread(ImageOps.invert, image)
        i = io.BytesIO()
        await asyncio.to_thread(imv.save, i, format="png")
        i.seek(0)
        await interaction.message.edit(attachments=[discord.File(i, "emoji.png")])
        file.close()
        i.close()

    @discord.ui.button(emoji="üíæ", style=discord.ButtonStyle.blurple)
    async def save(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user.id:
            return

        await interaction.response.defer(ephemeral=True)
        await interaction.message.edit(view=None)

    @discord.ui.select(
        options=[
            discord.SelectOption(label="90¬∞", value="90"),
            discord.SelectOption(label="180¬∞", value="180"),
            discord.SelectOption(label="270¬∞", value="270"),
        ],
        max_values=1,
        min_values=1,
        placeholder="ÂõûËª¢„Åô„Çã",
    )
    async def kaiten(self, interaction: discord.Interaction, select: discord.ui.Select):
        await interaction.response.defer(ephemeral=True)
        file = io.BytesIO(await interaction.message.attachments[0].read())
        image = await asyncio.to_thread(Image.open, file)
        imv = await asyncio.to_thread(image.rotate, int(select.values[0]))
        i = io.BytesIO()
        await asyncio.to_thread(imv.save, i, format="png")
        i.seek(0)
        await interaction.message.edit(attachments=[discord.File(i, "emoji.png")])
        file.close()
        i.close()


ASCII_CHARS = "@%#*+=-:. "


def resize_image(image, new_width=40, new_height=40):
    return image.resize((new_width, new_height))


def grayify(image):
    return image.convert("L")


def pixels_to_ascii(image):
    pixels = image.getdata()
    ascii_str = ""
    for pixel in pixels:
        ascii_str += ASCII_CHARS[pixel * len(ASCII_CHARS) // 256]
    return ascii_str


def image_to_ascii(image_path):
    try:
        image = Image.open(image_path)
    except Exception as e:
        return "Â§âÊèõ„Ç®„É©„Éº"

    image = resize_image(image)
    image = grayify(image)

    ascii_str = pixels_to_ascii(image)

    ascii_art = "\n".join(ascii_str[i : i + 40] for i in range(0, len(ascii_str), 40))
    return ascii_art


def text_len_sudden(text):
    count = 0
    for c in text:
        count += 2 if unicodedata.east_asian_width(c) in "FWA" else 1
    return count


def sudden_generator(msg):
    length = text_len_sudden(msg)
    generating = "Ôºø‰∫∫"
    for i in range(length // 2):
        generating += "‰∫∫"
    generating += "‰∫∫Ôºø\nÔºû  " + msg + "  Ôºú\nÔø£^Y"
    for i in range(length // 2):
        generating += "^Y"
    generating += "^YÔø£"
    return generating


async def fetch_avatar(user: discord.User):
    if user.avatar:
        url_a = f"https://cdn.discordapp.com/avatars/{user.id}/{user.avatar.key}"
    else:
        url_a = user.default_avatar.url
    async with aiohttp.ClientSession() as session:
        async with session.get(url_a, timeout=10) as resp:
            return await resp.read()


def wrap_text_with_ellipsis(text, font, draw, max_width, max_height, line_height):
    lines = []
    for raw_line in text.split("\n"):
        current_line = ""
        for char in raw_line:
            test_line = current_line + char
            bbox = draw.textbbox((0, 0), test_line, font=font)
            w = bbox[2] - bbox[0]
            if w <= max_width:
                current_line = test_line
            else:
                lines.append(current_line)
                current_line = char

            if len(lines) * line_height >= max_height - line_height * 2:
                ellipsis = "‚Ä¶"
                while True:
                    bbox = draw.textbbox((0, 0), current_line + ellipsis, font=font)
                    if bbox[2] - bbox[0] <= max_width:
                        break
                    if len(current_line) == 0:
                        break
                    current_line = current_line[:-1]
                lines.append(current_line + ellipsis)
                return lines

        if current_line:
            lines.append(current_line)

    return lines


def create_quote_image(
    author,
    text,
    avatar_bytes,
    background,
    textcolor,
    color: bool,
    negapoji: bool = False,
):
    width, height = 800, 400
    background_color = background
    text_color = textcolor

    img = Image.new("RGB", (width, height), background_color)
    draw = ImageDraw.Draw(img)

    avatar_size = (400, 400)
    avatar = Image.open(io.BytesIO(avatar_bytes)).convert("RGBA")
    avatar = avatar.resize(avatar_size)

    mask = Image.new("L", avatar_size, 255)
    for x in range(avatar_size[0]):
        alpha = (
            255
            if x < avatar_size[0] // 2
            else int(255 * (1 - (x - avatar_size[0] // 2) / (avatar_size[0] / 2)))
        )
        for y in range(avatar_size[1]):
            mask.putpixel((x, y), alpha)
    avatar.putalpha(mask)

    img.paste(avatar, (0, height - avatar_size[1]), avatar)

    try:
        font = ImageFont.truetype("data/DiscordFont.ttf", 30)
        name_font = ImageFont.truetype("data/DiscordFont.ttf", 20)
    except:
        font = ImageFont.load_default()
        name_font = ImageFont.load_default()

    text_x = 420
    max_text_width = width - text_x - 50

    max_text_height = height - 80
    line_height = font.size + 10

    lines = wrap_text_with_ellipsis(
        text, font, draw, max_text_width, max_text_height, line_height
    )

    total_lines = len(lines)
    line_height = font.size + 10
    text_block_height = total_lines * line_height
    text_y = (height - text_block_height) // 2

    for i, line in enumerate(lines):
        bbox = draw.textbbox((0, 0), line, font=font)
        line_width = bbox[2] - bbox[0]
        draw.text(
            ((width + text_x - 50 - line_width) // 2, text_y + i * line_height),
            line,
            fill=text_color,
            font=font,
        )

    author_text = f"- {author}"
    bbox = draw.textbbox((0, 0), author_text, font=name_font)
    author_width = bbox[2] - bbox[0]
    author_x = (width + text_x - 50 - author_width) // 2
    author_y = text_y + len(lines) * line_height + 10

    draw.text((author_x, author_y), author_text, font=name_font, fill=text_color)

    draw.text((580, 0), "FakeQuote - SharkBot", font=name_font, fill=text_color)

    if negapoji:
        inverted_img = ImageOps.invert(img.convert("RGB"))
        return inverted_img

    if color:
        return img
    else:
        return img.convert("L")


class AudioGroup(app_commands.Group):
    def __init__(self):
        super().__init__(name="audio", description="Èü≥Â£∞Á≥ª„ÅÆ„Ç≥„Éû„É≥„Éâ„Åß„Åô„ÄÇ")

    @app_commands.command(name="tts", description="„ÉÜ„Ç≠„Çπ„Éà„ÇíÈü≥Â£∞„Å´„Åó„Åæ„Åô„ÄÇ")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    @app_commands.choices(
        Â£∞„ÅÆÁ®ÆÈ°û=[
            app_commands.Choice(name="„ÇÜ„Å£„Åè„ÇäÈúäÂ§¢", value="reimu"),
            app_commands.Choice(name="„ÇÜ„Å£„Åè„ÇäÈ≠îÁêÜÊ≤ô", value="marisa"),
            app_commands.Choice(name="„Å≤„Çç„ÇÜ„Åç", value="hiroyuki"),
        ]
    )
    async def tts_(
        self,
        interaction: discord.Interaction,
        „ÉÜ„Ç≠„Çπ„Éà: str,
        Â£∞„ÅÆÁ®ÆÈ°û: app_commands.Choice[str],
    ):
        await interaction.response.defer()
        if Â£∞„ÅÆÁ®ÆÈ°û.value == "reimu":
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    f"https://www.yukumo.net/api/v2/aqtk1/koe.mp3?type=f1&kanji={urllib.parse.quote(„ÉÜ„Ç≠„Çπ„Éà)}"
                ) as response:
                    io_ = io.BytesIO(await response.read())
                    await interaction.followup.send(
                        file=discord.File(io_, filename="tts.mp3")
                    )
                    io_.close()
        elif Â£∞„ÅÆÁ®ÆÈ°û.value == "marisa":
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    f"https://www.yukumo.net/api/v2/aqtk1/koe.mp3?type=f2&kanji={urllib.parse.quote(„ÉÜ„Ç≠„Çπ„Éà)}"
                ) as response:
                    io_ = io.BytesIO(await response.read())
                    await interaction.followup.send(
                        file=discord.File(io_, filename="tts.mp3")
                    )
                    io_.close()
        elif Â£∞„ÅÆÁ®ÆÈ°û.value == "hiroyuki":
            json_data = {
                'variant': 'maker-tts',
                'text': „ÉÜ„Ç≠„Çπ„Éà,
            }
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    f"https://backend.coefont.cloud/coefonts/19d55439-312d-4a1d-a27b-28f0f31bedc5/try", json=json_data
                ) as response:
                    j = await response.json()
                    if not j.get('location'):
                        return await interaction.followup.send(embed=discord.Embed(title="Èü≥Â£∞ÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ", color=discord.Color.red()))
                    async with session.get(
                        j['location']
                    ) as response_wav:
                        io_ = io.BytesIO(await response_wav.read())
                        await interaction.followup.send(
                            file=discord.File(io_, filename="tts.wav")
                        )
                        io_.close()

    @app_commands.command(name="distortion", description="Èü≥Â£∞„ÇíÈü≥Ââ≤„Çå„Åï„Åõ„Åæ„Åô„ÄÇ")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    async def distortion(
        self, interaction: discord.Interaction, Èü≥Â£∞: discord.Attachment
    ):
        MAX_IMAGE_SIZE = 5 * 1024 * 1024
        if Èü≥Â£∞.size > MAX_IMAGE_SIZE:
            await interaction.response.send_message(
                f"Èü≥Â£∞„ÅØÊúÄÂ§ß 5MB „Åæ„ÅßÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ", ephemeral=True
            )
            return

        await interaction.response.defer()
        await aiofiles.os.makedirs(
            f"files/static/{interaction.user.id}/", exist_ok=True
        )

        input_audio = f"files/static/{interaction.user.id}/{uuid.uuid4()}.mp3"
        mp3_file = f"{uuid.uuid4()}.mp3"
        output_audio = f"files/static/{interaction.user.id}/{mp3_file}"

        async with aiohttp.ClientSession() as session:
            async with session.get(Èü≥Â£∞.url) as resp:
                resp.raise_for_status()
                async with aiofiles.open(input_audio, "wb") as f:
                    await f.write(await resp.read())

        cmd = ["ffmpeg", "-i", input_audio, "-af", "volume=31dB", output_audio]

        process = await asyncio.create_subprocess_exec(
            *cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
        )

        stdout, stderr = await process.communicate()

        if process.returncode != 0:
            await interaction.followup.send(f"Èü≥Â£∞Âá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ")
            return

        await interaction.followup.send(
            file=discord.File(output_audio, filename="distortion.mp3")
        )


class MovieGroup(app_commands.Group):
    def __init__(self):
        super().__init__(name="movie", description="ÂãïÁîªÁîüÊàêÁ≥ª„ÅÆ„Ç≥„Éû„É≥„Éâ„Åß„Åô„ÄÇ")

    @app_commands.command(
        name="sea", description="Êµ∑„ÅÆËÉåÊôØ„ÅÆÂãïÁîª„Å´ÁîªÂÉè„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Åæ„Åô„ÄÇ"
    )
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    async def sea(self, interaction: discord.Interaction, ÁîªÂÉè: discord.Attachment):
        MAX_IMAGE_SIZE = 5 * 1024 * 1024
        if ÁîªÂÉè.size > MAX_IMAGE_SIZE:
            await interaction.response.send_message(
                f"ÁîªÂÉè„ÅØÊúÄÂ§ß 5MB „Åæ„ÅßÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ", ephemeral=True
            )
            return

        await interaction.response.defer()
        await aiofiles.os.makedirs(
            f"files/static/{interaction.user.id}/", exist_ok=True
        )

        input_video = "data/sea.mp4"
        input_image = f"files/static/{interaction.user.id}/{uuid.uuid4()}.png"
        mp4_file = f"{uuid.uuid4()}.mp4"
        output_video = f"files/static/{interaction.user.id}/{mp4_file}"

        async with aiohttp.ClientSession() as session:
            async with session.get(ÁîªÂÉè.url) as resp:
                resp.raise_for_status()
                async with aiofiles.open(input_image, "wb") as f:
                    await f.write(await resp.read())

        def resize_image():
            img = Image.open(input_image)
            res_img = img.resize((300, 300))
            res_img.save(input_image, format="png")
            return

        await asyncio.to_thread(resize_image)

        cmd = [
            "ffmpeg",
            "-y",
            "-i",
            input_video,
            "-i",
            input_image,
            "-filter_complex",
            "overlay=(main_w-overlay_w)/2:(main_h-overlay_h)/2",
            output_video,
        ]

        process = await asyncio.create_subprocess_exec(
            *cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
        )

        stdout, stderr = await process.communicate()

        filepath = f"https://file.sharkbot.xyz/static/{interaction.user.id}/{mp4_file}"

        await interaction.followup.send(
            embed=discord.Embed(
                title="Êµ∑„ÅÆËÉåÊôØ„ÅÆÂãïÁîª„Å´ÁîªÂÉè„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„ÅüÂãïÁîª",
                description="‰∏ÄÊó•„ÅÆÁµÇ„Çè„Çä„Å´„Éï„Ç°„Ç§„É´„ÅåÂâäÈô§„Åï„Çå„Åæ„Åô„ÄÇ",
                color=discord.Color.green(),
            ),
            view=discord.ui.View().add_item(
                discord.ui.Button(label="ÁµêÊûú„ÇíÁ¢∫Ë™ç„Åô„Çã", url=filepath)
            ),
        )


class TextGroup(app_commands.Group):
    def __init__(self):
        super().__init__(name="text", description="„ÉÜ„Ç≠„Çπ„ÉàÁ≥ª„ÅÆÈù¢ÁôΩ„ÅÑ„Ç≥„Éû„É≥„Éâ")

    @app_commands.command(name="suddendeath", description="Á™ÅÁÑ∂„ÅÆÊ≠ª„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    async def suddendeath(
        self, interaction: discord.Interaction, „ÉÜ„Ç≠„Çπ„Éà: str = "Á™ÅÁÑ∂„ÅÆÊ≠ª"
    ):
        if not await command_disable.command_enabled_check(interaction):
            return await interaction.response.send_message(
                ephemeral=True, content="„Åù„ÅÆ„Ç≥„Éû„É≥„Éâ„ÅØÁÑ°ÂäπÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ"
            )

        await interaction.response.send_message(
            embed=discord.Embed(
                description=f"```{sudden_generator(„ÉÜ„Ç≠„Çπ„Éà)}```",
                title="Á™ÅÁÑ∂„ÅÆÊ≠ª",
                color=discord.Color.green(),
            )
        )

    @app_commands.command(name="retranslate", description="ÂÜçÁøªË®≥„Åó„Åæ„Åô„ÄÇ")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    async def retranslate(self, interaction: discord.Interaction, „ÉÜ„Ç≠„Çπ„Éà: str):
        if not await command_disable.command_enabled_check(interaction):
            return await interaction.response.send_message(
                ephemeral=True, content="„Åù„ÅÆ„Ç≥„Éû„É≥„Éâ„ÅØÁÑ°ÂäπÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ"
            )

        await interaction.response.defer()

        loop = asyncio.get_event_loop()

        desc = f"ja -> {„ÉÜ„Ç≠„Çπ„Éà}"
        msg = await interaction.followup.send(
            embed=discord.Embed(
                title="‰ΩïÂõû„ÇÇÁøªË®≥ (ja)", description=desc, color=discord.Color.green()
            )
        )

        word = „ÉÜ„Ç≠„Çπ„Éà
        langs = ["en", "zh-CN", "ko", "ru", "ja"]

        for lang in langs:
            await asyncio.sleep(3)
            word_ = await loop.run_in_executor(
                None, partial(GoogleTranslator, source="auto", target=lang)
            )
            word = await loop.run_in_executor(None, partial(word_.translate, word))

            desc += f"\n{lang} -> {word}"
            await msg.edit(
                embed=discord.Embed(
                    title=f"‰ΩïÂõû„ÇÇÁøªË®≥ ({lang})",
                    description=desc,
                    color=discord.Color.green(),
                )
            )

        await asyncio.sleep(3)
        await msg.edit(
            embed=discord.Embed(
                title="‰ΩïÂõû„ÇÇÁøªË®≥",
                description=f"{desc}\nÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇ",
                color=discord.Color.green(),
            )
        )

    @app_commands.command(
        name="text-to-emoji", description="„ÉÜ„Ç≠„Çπ„Éà„ÇíÁµµÊñáÂ≠óÂåñ„Åó„Åæ„Åô„ÄÇ"
    )
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    async def text_to_emoji(self, interaction: discord.Interaction, „ÉÜ„Ç≠„Çπ„Éà: str):
        if not await command_disable.command_enabled_check(interaction):
            return await interaction.response.send_message(
                ephemeral=True, content="„Åù„ÅÆ„Ç≥„Éû„É≥„Éâ„ÅØÁÑ°ÂäπÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ"
            )

        await interaction.response.defer()

        async def text_emoji(text):
            kakasi = pykakasi.kakasi()
            result = kakasi.convert(text)

            def text_to_discord_emoji(text):
                emoji_map = {chr(97 + i): chr(0x1F1E6 + i) for i in range(26)}
                num_emoji_map = {str(i): f"{i}Ô∏è‚É£" for i in range(10)}
                return [
                    emoji_map[char.lower()]
                    if char.isalpha()
                    else num_emoji_map[char]
                    if char.isdigit()
                    else None
                    for char in text
                    if char.isalnum()
                ]

            romaji_text = "".join(item["kunrei"] for item in result if "kunrei" in item)
            emojis = text_to_discord_emoji(romaji_text)

            return emojis

        ems = await text_emoji(„ÉÜ„Ç≠„Çπ„Éà[:20])
        await interaction.followup.send(content=" ".join(ems))

    @app_commands.command(name="reencode", description="ÊñáÂ≠óÂåñ„Åë„Çí‰ΩúÊàê„Åó„Åæ„Åô„ÄÇ")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    async def reencode(self, interaction: discord.Interaction, „ÉÜ„Ç≠„Çπ„Éà: str):
        if not await command_disable.command_enabled_check(interaction):
            return await interaction.response.send_message(
                ephemeral=True, content="„Åù„ÅÆ„Ç≥„Éû„É≥„Éâ„ÅØÁÑ°ÂäπÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ"
            )

        await interaction.response.send_message(
            embed=discord.Embed(
                title="ÊñáÂ≠óÂåñ„Åë",
                description=encode(„ÉÜ„Ç≠„Çπ„Éà).decode("sjis", errors="ignore"),
                color=discord.Color.green(),
            )
        )

    @app_commands.command(name="crypt", description="ÊñáÂ≠óÂàó„ÇíÊöóÂè∑Âåñ„Åó„Åæ„Åô„ÄÇ")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    async def crypt_text(
        self,
        interaction: discord.Interaction,
        „ÉÜ„Ç≠„Çπ„Éà: str = None,
        ÊöóÂè∑: str = None,
        ÊöóÂè∑Âåñ„Ç≠„Éº: str = None,
    ):
        if not await command_disable.command_enabled_check(interaction):
            return await interaction.response.send_message(
                ephemeral=True, content="„Åù„ÅÆ„Ç≥„Éû„É≥„Éâ„ÅØÁÑ°ÂäπÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ"
            )

        if „ÉÜ„Ç≠„Çπ„Éà and not ÊöóÂè∑ and not ÊöóÂè∑Âåñ„Ç≠„Éº:
            key = Fernet.generate_key()
            f = Fernet(key)
            token = f.encrypt(„ÉÜ„Ç≠„Çπ„Éà.encode())
            embed = discord.Embed(title="ÊöóÂè∑ÂåñÂÆå‰∫Ü", color=discord.Color.green())
            embed.add_field(name="ÊöóÂè∑", value=token.decode(), inline=False)
            embed.add_field(name="ÊöóÂè∑Âåñ„Ç≠„Éº", value=key.decode(), inline=False)
            await interaction.response.send_message(embed=embed)

        elif ÊöóÂè∑ and ÊöóÂè∑Âåñ„Ç≠„Éº and not „ÉÜ„Ç≠„Çπ„Éà:
            try:
                f = Fernet(ÊöóÂè∑Âåñ„Ç≠„Éº.encode())
                decrypted = f.decrypt(ÊöóÂè∑.encode())
                embed = discord.Embed(title="Âæ©Âè∑ÂåñÂÆå‰∫Ü", color=discord.Color.green())
                embed.add_field(name="Âæ©ÂÖÉÁµêÊûú", value=decrypted.decode(), inline=False)
                await interaction.response.send_message(embed=embed)
            except InvalidToken:
                await interaction.response.send_message(
                    embed=discord.Embed(
                        title="Âæ©Âè∑„Ç®„É©„Éº",
                        description="ÁÑ°Âäπ„Å™ÊöóÂè∑„Åæ„Åü„ÅØ„Ç≠„Éº„Åß„Åô„ÄÇ",
                        color=discord.Color.red(),
                    )
                )
            except Exception as e:
                await interaction.response.send_message(
                    embed=discord.Embed(
                        title="„Ç®„É©„Éº", description=str(e), color=discord.Color.red()
                    )
                )
        else:
            await interaction.response.send_message(
                embed=discord.Embed(
                    title="‰ΩøÁî®ÊñπÊ≥ï„Ç®„É©„Éº",
                    description="ÊöóÂè∑Âåñ„Å´„ÅØ `„ÉÜ„Ç≠„Çπ„Éà` „Çí„ÄÅÂæ©Âè∑„Å´„ÅØ `ÊöóÂè∑` „Å® `ÊöóÂè∑Âåñ„Ç≠„Éº` „ÇíÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
                    color=discord.Color.orange(),
                )
            )

    @app_commands.command(name="number", description="ÈÄ≤Êï∞„ÇíÂ§âÊõ¥„Åó„Åæ„Åô„ÄÇ")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    async def number(self, interaction: discord.Interaction, ÈÄ≤Êï∞: int, Êï∞Â≠ó: str):
        if ÈÄ≤Êï∞ < 2 or ÈÄ≤Êï∞ > 16:
            return await interaction.response.send_message(
                embed=discord.Embed(
                    title="ÂØæÂøú„Åó„Å¶„ÅÑ„Å™„ÅÑÈÄ≤Êï∞„Åß„Åô„ÄÇ",
                    description="2ÔΩû16ÈÄ≤Êï∞„Åæ„ÅßÂØæÂøú„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ",
                    color=discord.Color.red(),
                )
            )

        try:
            result = int(Êï∞Â≠ó, ÈÄ≤Êï∞)
        except ValueError:
            return await interaction.response.send_message(
                embed=discord.Embed(
                    title="Â§âÊèõ„Ç®„É©„Éº",
                    description=f"ÂÖ•Âäõ `{Êï∞Â≠ó}` „ÅØ {ÈÄ≤Êï∞} ÈÄ≤Êï∞„Å®„Åó„Å¶ÁÑ°Âäπ„Åß„Åô„ÄÇ",
                    color=discord.Color.red(),
                )
            )

        await interaction.response.send_message(
            embed=discord.Embed(
                title="ÈÄ≤Êï∞„ÇíÂ§âÊèõ„Åó„Åæ„Åó„Åü„ÄÇ",
                description=f"`{Êï∞Â≠ó}` ({ÈÄ≤Êï∞}ÈÄ≤Êï∞) ‚Üí `{result}` (10ÈÄ≤Êï∞)",
                color=discord.Color.green(),
            )
        )

    @app_commands.command(name="arm", description="arm„ÅÆasm„Çí„ÄÅ„Éê„Ç§„Éä„É™„Å´Â§âÊèõ„Åó„Åæ„Åô„ÄÇ")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    async def arm_byte(self, interaction: discord.Interaction):
        class send(discord.ui.Modal):
            def __init__(self) -> None:
                super().__init__(title="Arm„Çí„Éê„Ç§„Éä„É™„Å´Â§âÊèõ", timeout=None)

            asm = discord.ui.TextInput(
                label="ASM„ÇíÂÖ•Âäõ", style=discord.TextStyle.long, required=True
            )

            async def on_submit(self, interaction_: discord.Interaction) -> None:
                await interaction_.response.defer()
                try:
                    payload = {
                        "asm": self.asm.value,
                        "offset": "",
                        "arch": ["arm64", "arm", "thumb"],
                    }
                    async with aiohttp.ClientSession() as session:
                        async with session.post(
                            "https://armconverter.com/api/convert",
                            data=json.dumps(payload),
                        ) as response:
                            js = await response.json()
                            hex_list = js.get("hex", {}).get("arm", [])
                            hex_result = (
                                hex_list[1]
                                if len(hex_list) > 1
                                else "ÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü"
                            )
                            await interaction_.followup.send(
                                embed=discord.Embed(
                                    title="ARM„ÅÆ„Éê„Ç§„Éä„É™",
                                    description=f"```{hex_result}```",
                                    color=discord.Color.green(),
                                )
                            )
                except Exception as e:
                    await interaction_.followup.send(
                        ephemeral=True, content=f"„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: {e}"
                    )

        await interaction.response.send_modal(send())


class NounaiGroup(app_commands.Group):
    def __init__(self):
        super().__init__(name="nounai", description="ËÑ≥ÂÜÖ„É°„Éº„Ç´„ÉºÁ≥ª„ÅÆÈù¢ÁôΩ„ÅÑ„Ç≥„Éû„É≥„Éâ")

    @app_commands.command(name="nounai", description="ËÑ≥ÂÜÖ„É°„Éº„Ç´„Éº„ÅßÈÅä„Å≥„Åæ„Åô")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    async def nounai(self, interaction: discord.Interaction, ÂêçÂâç: str):
        await interaction.response.send_message(
            embed=discord.Embed(
                title="ËÑ≥ÂÜÖ„É°„Éº„Ç´„Éº", color=discord.Color.green()
            ).set_image(
                url=f"https://maker.usoko.net/nounai/img/{urllib.parse.quote(ÂêçÂâç)}.gif"
            )
        )

    @app_commands.command(name="kakeizu", description="ÂÆ∂Á≥ªÂõ≥„É°„Éº„Ç´„Éº„ÅßÈÅä„Å≥„Åæ„Åô")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    async def kakeizu(self, interaction: discord.Interaction, ÂêçÂâç: str):
        await interaction.response.send_message(
            embed=discord.Embed(
                title="ÂÆ∂Á≥ªÂõ≥„É°„Éº„Ç´„Éº", color=discord.Color.green()
            ).set_image(
                url=f"https://usokomaker.com/kakeizu_fantasy/r/img/{urllib.parse.quote(ÂêçÂâç)}.gif"
            )
        )

    @app_commands.command(name="busyo", description="Ê≠¶Â∞Ü„É°„Éº„Ç´„Éº„ÅßÈÅä„Å≥„Åæ„Åô")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    async def busyo(self, interaction: discord.Interaction, ÂêçÂâç: str):
        await interaction.response.send_message(
            embed=discord.Embed(
                title="Ê≠¶Â∞Ü„É°„Éº„Ç´„Éº", color=discord.Color.green()
            ).set_image(
                url=f"https://usokomaker.com/busyo/img/{urllib.parse.quote(ÂêçÂâç)}.gif"
            )
        )

    @app_commands.command(name="kabuto", description="ÂÖú„É°„Éº„Ç´„Éº„ÅßÈÅä„Å≥„Åæ„Åô")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    async def kabuto(self, interaction: discord.Interaction, ÂêçÂâç: str):
        await interaction.response.send_message(
            embed=discord.Embed(
                title="ÂÖú„É°„Éº„Ç´„Éº", color=discord.Color.green()
            ).set_image(
                url=f"https://usokomaker.com/kabuto/img/{urllib.parse.quote(ÂêçÂâç)}.gif"
            )
        )

    @app_commands.command(name="tenshoku", description="Ëª¢ËÅ∑„É°„Éº„Ç´„Éº„ÅßÈÅä„Å≥„Åæ„Åô")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    async def tenshoku(self, interaction: discord.Interaction, ÂêçÂâç: str):
        await interaction.response.send_message(
            embed=discord.Embed(
                title="Ëª¢ËÅ∑„É°„Éº„Ç´„Éº", color=discord.Color.green()
            ).set_image(
                url=f"https://usokomaker.com/tenshoku/img/{urllib.parse.quote(ÂêçÂâç)}.gif"
            )
        )

class ImageGroup(app_commands.Group):
    def __init__(self):
        super().__init__(name="image", description="ÁîªÂÉèÁ≥ª„ÅÆÈù¢ÁôΩ„ÅÑ„Ç≥„Éû„É≥„Éâ")

    @app_commands.command(name="cat", description="„Éç„Ç≥„ÅÆÁîªÂÉè„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    async def cat(self, interaction: discord.Interaction):
        if not await command_disable.command_enabled_check(interaction):
            return await interaction.response.send_message(
                ephemeral=True, content="„Åù„ÅÆ„Ç≥„Éû„É≥„Éâ„ÅØÁÑ°ÂäπÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ"
            )

        async with aiohttp.ClientSession() as session:
            async with session.get(
                "https://api.thecatapi.com/v1/images/search?size=med&mime_types=jpg&format=json&has_breeds=true&order=RANDOM&page=0&limit=1"
            ) as cat:
                msg = await interaction.response.send_message(
                    embed=discord.Embed(
                        title="Áå´„ÅÆÁîªÂÉè", color=discord.Color.green()
                    ).set_image(url=json.loads(await cat.text())[0]["url"])
                )

    @app_commands.command(name="dog", description="Áä¨„ÅÆÁîªÂÉè„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    async def dog(self, interaction: discord.Interaction):
        if not await command_disable.command_enabled_check(interaction):
            return await interaction.response.send_message(
                ephemeral=True, content="„Åù„ÅÆ„Ç≥„Éû„É≥„Éâ„ÅØÁÑ°ÂäπÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ"
            )

        async with aiohttp.ClientSession() as session:
            async with session.get("https://dog.ceo/api/breeds/image/random") as dog_:
                await interaction.response.send_message(
                    embed=discord.Embed(
                        title="Áä¨„ÅÆÁîªÂÉè", color=discord.Color.green()
                    ).set_image(url=f"{json.loads(await dog_.text())['message']}")
                )

    @app_commands.command(name="5000", description="5000ÂÖÜÂÜÜ„Åª„Åó„ÅÑÔºÅ")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    async def _5000(
        self,
        interaction: discord.Interaction,
        ‰∏ä: str,
        ‰∏ã: str,
        no„Ç¢„É´„Éï„Ç°: bool = None,
    ):
        if not await command_disable.command_enabled_check(interaction):
            return await interaction.response.send_message(
                ephemeral=True, content="„Åù„ÅÆ„Ç≥„Éû„É≥„Éâ„ÅØÁÑ°ÂäπÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ"
            )

        if no„Ç¢„É´„Éï„Ç°:
            if no„Ç¢„É´„Éï„Ç° == False:
                msg = await interaction.response.send_message(
                    embed=discord.Embed(
                        title="5000ÂÖÜÂÜÜ„Åª„Åó„ÅÑÔºÅ", color=discord.Color.green()
                    ).set_image(url=f"https://gsapi.cbrx.io/image?top={‰∏ä}&bottom={‰∏ã}")
                )
            else:
                msg = await interaction.response.send_message(
                    embed=discord.Embed(
                        title="5000ÂÖÜÂÜÜ„Åª„Åó„ÅÑÔºÅ", color=discord.Color.green()
                    ).set_image(
                        url=f"https://gsapi.cbrx.io/image?top={‰∏ä}&bottom={‰∏ã}&noalpha=true"
                    )
                )
        else:
            msg = await interaction.response.send_message(
                embed=discord.Embed(
                    title="5000ÂÖÜÂÜÜ„Åª„Åó„ÅÑÔºÅ", color=discord.Color.green()
                ).set_image(url=f"https://gsapi.cbrx.io/image?top={‰∏ä}&bottom={‰∏ã}")
            )

    @app_commands.command(name="textmoji", description="„ÉÜ„Ç≠„Çπ„Éà„ÇíÁµµÊñáÂ≠ó„Å´„Åó„Åæ„Åô„ÄÇ")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    @app_commands.choices(
        Ëâ≤=[
            app_commands.Choice(name="Ëµ§", value="FF0000"),
            app_commands.Choice(name="Èùí", value="1111FF"),
            app_commands.Choice(name="ÈªÑ", value="FFFF00"),
            app_commands.Choice(name="Èªí", value="000000"),
        ]
    )
    async def textmoji(
        self,
        interaction: discord.Interaction,
        Ëâ≤: app_commands.Choice[str],
        „ÉÜ„Ç≠„Çπ„Éà: str,
        Ê≠£ÊñπÂΩ¢„Å´„Åô„Çã„Åã: bool
    ):
        await interaction.response.defer()
        def make_text(text: str, color: str, sq: bool):
            font = ImageFont.truetype("data/DiscordFont.ttf", 50)

            dummy_img = Image.new("RGBA", (1, 1))
            draw_dummy = ImageDraw.Draw(dummy_img)
            bbox = draw_dummy.textbbox((0, 0), text, font=font)
            text_w = bbox[2] - bbox[0]
            text_h = bbox[3] - bbox[1]

            padding = 0
            img = Image.new("RGBA", (text_w + padding*2, text_h + padding*2), (255, 255, 255, 0))
            draw = ImageDraw.Draw(img)

            draw.text((padding - bbox[0], padding - bbox[1]), text, fill=f"#{color}", font=font)

            if sq:
                img = img.resize((200, 200))

            i = io.BytesIO()
            img.save(i, format="PNG")
            i.seek(0)
            return i
                
        image = await asyncio.to_thread(make_text, „ÉÜ„Ç≠„Çπ„Éà, Ëâ≤.value, Ê≠£ÊñπÂΩ¢„Å´„Åô„Çã„Åã)

        await interaction.followup.send(
            file=discord.File(image, "emoji.png"),
            view=EditImageView(interaction.user),
        )
        image.close()

    @app_commands.command(name="httpcat", description="http„Ç≠„É£„ÉÉ„Éà„ÇíÂèñÂæó„Åó„Åæ„Åô„ÄÇ")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    async def httpcat(self, interaction: discord.Interaction, „Çπ„ÉÜ„Éº„Çø„Çπ„Ç≥„Éº„Éâ: int):
        if not await command_disable.command_enabled_check(interaction):
            return await interaction.response.send_message(
                ephemeral=True, content="„Åù„ÅÆ„Ç≥„Éû„É≥„Éâ„ÅØÁÑ°ÂäπÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ"
            )

        embed = (
            discord.Embed(title="HTTPCat", color=discord.Color.blue())
            .set_image(url=f"https://http.cat/{„Çπ„ÉÜ„Éº„Çø„Çπ„Ç≥„Éº„Éâ}")
            .set_footer(text="Httpcat", icon_url="https://i.imgur.com/6mKRXgR.png")
        )
        await interaction.response.send_message(embed=embed)

    @app_commands.command(name="miq", description="Make it a quote„Çí‰ΩúÊàê„Åó„Åæ„Åô„ÄÇ")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    @app_commands.choices(
        Ëâ≤=[
            app_commands.Choice(name="„Ç´„É©„Éº", value="color"),
            app_commands.Choice(name="ÁôΩÈªí", value="black"),
            app_commands.Choice(name="„Éç„Ç¨„Éù„Ç∏ÂèçËª¢", value="negapoji"),
        ]
    )
    @app_commands.choices(
        ËÉåÊôØËâ≤=[
            app_commands.Choice(name="Èªí", value="black"),
            app_commands.Choice(name="ÁôΩ", value="white"),
        ]
    )
    async def miq(
        self,
        interaction: discord.Interaction,
        „É¶„Éº„Ç∂„Éº: discord.User,
        Áô∫Ë®Ä: str,
        Ëâ≤: app_commands.Choice[str],
        ËÉåÊôØËâ≤: app_commands.Choice[str],
    ):
        if not await command_disable.command_enabled_check(interaction):
            return await interaction.response.send_message(
                ephemeral=True, content="„Åù„ÅÆ„Ç≥„Éû„É≥„Éâ„ÅØÁÑ°ÂäπÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ"
            )

        await interaction.response.defer()
        avatar = „É¶„Éº„Ç∂„Éº
        av = await fetch_avatar(avatar)
        negapoji = False
        if Ëâ≤.value == "color":
            color = True
        elif Ëâ≤.value == "negapoji":
            color = True
            negapoji = True
        else:
            color = False
        if ËÉåÊôØËâ≤.value == "black":
            back = (0, 0, 0)
            text = (255, 255, 255)
        elif ËÉåÊôØËâ≤.value == "white":
            back = (255, 255, 255)
            text = (0, 0, 0)
        c = 0
        while True:
            if c > 8:
                return await interaction.followup.send(
                    embed=discord.Embed(
                        title="‰∫àÊúü„Åó„Å™„ÅÑ„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ",
                        color=discord.Color.red(),
                    )
                )
            miq = await asyncio.to_thread(
                create_quote_image,
                „É¶„Éº„Ç∂„Éº.display_name,
                Áô∫Ë®Ä,
                av,
                back,
                text,
                color,
                negapoji,
            )
            image_binary = io.BytesIO()
            await asyncio.to_thread(miq.save, image_binary, "PNG")
            image_binary.seek(0)
            try:
                file = discord.File(fp=image_binary, filename="fake_quote.png")
                await interaction.followup.send(
                    file=file, content=f"-# {c}ÂõûÂÜçË©¶Ë°å„Åó„Åæ„Åó„Åü„ÄÇ"
                )
            except aiohttp.ClientOSError:
                c += 1
                await asyncio.sleep(0.5)
                continue
            image_binary.close()
            await quest.quest_clear(interaction, "miq")
            return

    @app_commands.command(name="ascii", description="„Ç¢„Çπ„Ç≠„Éº„Ç¢„Éº„Éà„Çí‰ΩúÊàê„Åó„Åæ„Åô„ÄÇ")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    async def ascii(self, interaction: discord.Interaction, ÁîªÂÉè: discord.Attachment):
        await interaction.response.defer()
        rd = await ÁîªÂÉè.read()
        io_ = io.BytesIO(rd)
        io_.seek(0)
        text = await asyncio.to_thread(image_to_ascii, io_)
        st = io.StringIO(text)
        await interaction.followup.send(file=discord.File(st, "ascii.txt"))
        st.close()
        io_.close()

    @app_commands.command(name="imgur", description="Imgur„ÅßÁîªÂÉè„ÇíÂèñÂæó„Åó„Åæ„Åô„ÄÇ")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    async def imgur(self, interaction: discord.Interaction, Ê§úÁ¥¢„ÉØ„Éº„Éâ: str):
        await interaction.response.defer()
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    f"https://api.imgur.com/3/gallery/search",
                    params={"q": Ê§úÁ¥¢„ÉØ„Éº„Éâ},
                    headers={"Authorization": f"Client-ID {settings.IMGUR_CLIENTID}"},
                ) as resp:
                    data = await resp.json()

                    if data and "data" in data:
                        for item in data["data"]:
                            return await interaction.followup.send(f"{item['link']}")

                    return await interaction.followup.send(
                        f"ÁµêÊûú„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ"
                    )
        except:
            return await interaction.followup.send(f"Ê§úÁ¥¢„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ")

    @app_commands.command(name="profile", description="Ëá™Â∑±Á¥π‰ªã„Ç´„Éº„Éâ„Çí‰ΩúÊàê„Åó„Åæ„Åô„ÄÇ")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    async def profile_card(self, interaction: discord.Interaction):
        class CardModal(discord.ui.Modal):
            def __init__(self):
                super().__init__(title="Ëá™Â∑±Á¥π‰ªã„Ç´„Éº„Éâ„Çí‰ΩúÊàê", timeout=180)

            introduction = discord.ui.Label(
                text="Ëá™Â∑±Á¥π‰ªã„ÇíÂÖ•Âäõ",
                description="Ëá™Â∑±Á¥π‰ªã„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
                component=discord.ui.TextInput(
                    style=discord.TextStyle.long, required=True
                ),
            )

            async def on_submit(self, interaction_: discord.Interaction):
                await interaction_.response.defer()

                assert isinstance(self.introduction.component, discord.ui.TextInput)

                async with aiohttp.ClientSession() as session:
                    async with session.get(
                        str(
                            interaction.user.avatar.url
                            if interaction.user.avatar
                            else interaction.user.default_avatar.url
                        )
                    ) as resp:
                        avatar_bytes = await resp.read()

                def make_card(
                    user: discord.User, avatar_bytes: io.BytesIO, introduction: str
                ):
                    img = Image.new("RGB", (600, 300), color=(54, 57, 63))
                    draw = ImageDraw.Draw(img)

                    try:
                        font_title = ImageFont.truetype("data/DiscordFont.ttf", 30)
                        font_text = ImageFont.truetype("data/DiscordFont.ttf", 20)
                    except:
                        font_title = ImageFont.load_default()
                        font_text = ImageFont.load_default()

                    avatar = Image.open(avatar_bytes).convert("RGB")
                    avatar = avatar.resize((128, 128))

                    mask = Image.new("L", avatar.size, 0)
                    mask_draw = ImageDraw.Draw(mask)
                    mask_draw.ellipse((0, 0, 128, 128), fill=255)
                    img.paste(avatar, (30, 30), mask)

                    draw.text(
                        (180, 40),
                        f"{user.name}#{user.discriminator}",
                        font=font_title,
                        fill=(255, 255, 255),
                    )
                    draw.text(
                        (180, 100),
                        f"ID: {user.id}",
                        font=font_text,
                        fill=(200, 200, 200),
                    )
                    draw.text(
                        (30, 200),
                        f"Ëá™Â∑±Á¥π‰ªã: {introduction}",
                        font=font_text,
                        fill=(255, 255, 255),
                    )

                    image_binary = io.BytesIO()

                    img.save(image_binary, "PNG")
                    image_binary.seek(0)
                    return image_binary

                a_io = io.BytesIO(avatar_bytes)

                i = await asyncio.to_thread(
                    make_card, interaction.user, a_io, self.introduction.component.value
                )
                a_io.close()

                await interaction_.followup.send(
                    file=discord.File(i, filename="profile.png")
                )
                i.close()

        await interaction.response.send_modal(CardModal())


class FunCog(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        print("init -> FunCog")

    fun = app_commands.Group(name="fun", description="Èù¢ÁôΩ„ÅÑ„Ç≥„Éû„É≥„Éâ„Åß„Åô„ÄÇ")

    fun.add_command(TextGroup())
    fun.add_command(ImageGroup())
    fun.add_command(NounaiGroup())
    fun.add_command(MovieGroup())
    fun.add_command(AudioGroup())

    @fun.command(name="janken", description="„Åò„ÇÉ„Çì„Åë„Çì„Çí„Åó„Åæ„Åô„ÄÇ")
    @app_commands.allowed_contexts(guilds=True, dms=False, private_channels=True)
    @app_commands.checks.cooldown(2, 10, key=lambda i: i.guild_id)
    async def janken(self, interaction: discord.Interaction):
        if not await command_disable.command_enabled_check(interaction):
            return await interaction.response.send_message(
                ephemeral=True, content="„Åù„ÅÆ„Ç≥„Éû„É≥„Éâ„ÅØÁÑ°ÂäπÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ"
            )

        bot = random.choice(["„Åê„Éº", "„Å°„Çá„Åç", "„Å±„Éº"])

        def check(user: str, bot: str):
            if user == bot:
                return "„ÅÇ„ÅÑ„Åì„Åß„Åô\n„ÇÇ„ÅÜ‰∏ÄÂõû„ÇÑ„Å£„Å¶„Åø„ÇãÔºü"
            if user == "„Åê„Éº" and bot == "„Å°„Çá„Åç":
                return "„ÅÇ„Å™„Åü„ÅÆÂãù„Å°\n„ÇÇ„ÅÜ‰∏ÄÂõû„ÇÑ„Å£„Å¶„Åø„ÇãÔºü"
            if user == "„Å°„Çá„Åç" and bot == "„Å±„Éº":
                return "„ÅÇ„Å™„Åü„ÅÆÂãù„Å°\n„ÇÇ„ÅÜ‰∏ÄÂõû„ÇÑ„Å£„Å¶„Åø„ÇãÔºü"
            if user == "„Å±„Éº" and bot == "„Åê„Éº":
                return "„ÅÇ„Å™„Åü„ÅÆÂãù„Å°\n„ÇÇ„ÅÜ‰∏ÄÂõû„ÇÑ„Å£„Å¶„Åø„ÇãÔºü"
            return "Bot„ÅÆÂãù„Å°\n„ÇÇ„ÅÜ‰∏ÄÂõû„ÉÅ„É£„É¨„É≥„Ç∏„Åó„Å¶„Å≠ÔºÅ"

        class AnsView(discord.ui.View):
            def __init__(self):
                super().__init__(timeout=180)

            @discord.ui.button(label="„Åê„Éº", style=discord.ButtonStyle.blurple)
            async def goo(
                self, interaction: discord.Interaction, button: discord.ui.Button
            ):
                await interaction.response.defer(ephemeral=True)
                if interaction.user.id != interaction.user.id:
                    return await interaction.followup.send(
                        ephemeral=True, content="„ÅÇ„Å™„Åü„ÅÆ„Éú„Çø„É≥„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ"
                    )
                await interaction.message.edit(
                    view=None,
                    embed=discord.Embed(
                        title="„Åò„ÇÉ„Çì„Åë„Çì",
                        description=f"„ÅÇ„Å™„Åü: {button.label}\nBot: {bot}\n\n"
                        + check(button.label, bot),
                        color=discord.Color.blue(),
                    ),
                )

            @discord.ui.button(label="„Å°„Çá„Åç", style=discord.ButtonStyle.blurple)
            async def choki(
                self, interaction: discord.Interaction, button: discord.ui.Button
            ):
                await interaction.response.defer(ephemeral=True)
                if interaction.user.id != interaction.user.id:
                    return await interaction.followup.send(
                        ephemeral=True, content="„ÅÇ„Å™„Åü„ÅÆ„Éú„Çø„É≥„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ"
                    )
                await interaction.message.edit(
                    view=None,
                    embed=discord.Embed(
                        title="„Åò„ÇÉ„Çì„Åë„Çì",
                        description=f"„ÅÇ„Å™„Åü: {button.label}\nBot: {bot}\n\n"
                        + check(button.label, bot),
                        color=discord.Color.blue(),
                    ),
                )

            @discord.ui.button(label="„Å±„Éº", style=discord.ButtonStyle.blurple)
            async def par(
                self, interaction: discord.Interaction, button: discord.ui.Button
            ):
                await interaction.response.defer(ephemeral=True)
                if interaction.user.id != interaction.user.id:
                    return await interaction.followup.send(
                        ephemeral=True, content="„ÅÇ„Å™„Åü„ÅÆ„Éú„Çø„É≥„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ"
                    )
                await interaction.message.edit(
                    view=None,
                    embed=discord.Embed(
                        title="„Åò„ÇÉ„Çì„Åë„Çì",
                        description=f"„ÅÇ„Å™„Åü: {button.label}\nBot: {bot}\n\n"
                        + check(button.label, bot),
                        color=discord.Color.blue(),
                    ),
                )

            @discord.ui.button(label="„ÅÇ„Åç„Çâ„ÇÅ„Çã", style=discord.ButtonStyle.red)
            async def exit(
                self, interaction: discord.Interaction, button: discord.ui.Button
            ):
                await interaction.response.defer(ephemeral=True)
                if interaction.user.id != interaction.user.id:
                    return await interaction.followup.send(
                        ephemeral=True, content="„ÅÇ„Å™„Åü„ÅÆ„Éú„Çø„É≥„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ"
                    )
                await interaction.message.edit(
                    view=None,
                    embed=discord.Embed(
                        title="„Åò„ÇÉ„Çì„Åë„Çì",
                        description="Bot„ÅÆÂãù„Å°\n„ÇÇ„ÅÜ‰∏ÄÂõû„ÉÅ„É£„É¨„É≥„Ç∏„Åó„Å¶„Å≠ÔºÅ",
                        color=discord.Color.blue(),
                    ),
                )

        await interaction.response.send_message(
            embed=discord.Embed(
                title="„Åò„ÇÉ„Çì„Åë„Çì",
                description="""
„Éª„Ç∞„Éº„ÅØ„ÉÅ„Éß„Ç≠„Å´Âãù„Å°„ÄÅ„Éë„Éº„Å´Ë≤†„Åë„Åæ„Åô
„Éª„ÉÅ„Éß„Ç≠„ÅØ„Éë„Éº„Å´Âãù„Å°„ÄÅ„Ç∞„Éº„Å´Ë≤†„Åë„Åæ„Åô
„Éª„Éë„Éº„ÅØ„Ç∞„Éº„Å´Âãù„Å°„ÄÅ„ÉÅ„Éß„Ç≠„Å´Ë≤†„Åë„Åæ„Åô
Âêå„ÅòÊâã„Çí‰∏°ËÄÖ„ÅåÂá∫„Åó„ÅüÂ†¥Âêà„ÅØ„ÄÅ„ÅÇ„ÅÑ„Åì„Å®„Å™„Çä„Åæ„Åô„ÄÇ
""",
                color=discord.Color.blue(),
            ),
            view=AnsView(),
        )


async def setup(bot: commands.Bot):
    await bot.add_cog(FunCog(bot))
